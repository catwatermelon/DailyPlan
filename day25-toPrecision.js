// 拿 173.8125 举例如何将之转化为二进制小数。
// ①. 针对整数部分 173，采取除 2 取余，逆序排列;
// 173 / 2 = 86 ... 1
// 86 / 2 = 43 ... 0
// 43 / 2 = 21 ... 1   ↑
// 21 / 2 = 10 ... 1   | 逆序排列
// 10 / 2 = 5 ... 0    |
// 5 / 2 = 2 ... 1     |
// 2 / 2 = 1 ... 0
// 1 / 2 = 0 ... 1
// 得整数部分的二进制为 10101101。

// ②. 针对小数部分 0.8125，采用乘 2 取整，顺序排列;
// 0.8125 * 2 = 1.625  |
// 0.625 * 2 = 1.25    | 顺序排列
// 0.25 * 2 = 0.5      |
// 0.5 * 2 = 1         ↓
// ③. 将前面两部的结果相加，结果为 10101101.1101;

// 根据上面的知识，将十进制小数 0.1 转为二进制：
// 0.1 * 2 = 0.2
// 0.2 * 2 = 0.4 // 注意这里
// 0.4 * 2 = 0.8
// 0.8 * 2 = 1.6
// 0.6 * 2 = 1.2
// 0.2 * 2 = 0.4 // 注意这里，循环开始
// 0.4 * 2 = 0.8
// 0.8 * 2 = 1.6
// 0.6 * 2 = 1.2
// ...
// 可以发现有限十进制小数 0.1 却转化成了无限二进制小数 0.00011001100...，可以看到精度在转化过程中丢失了！
// 能被转化为有限二进制小数的十进制小数的最后一位必然以 5 结尾(因为只有 0.5 * 2 才能变为整数)。
// 所以十进制中一位小数 0.1 ~ 0.9 当中除了 0.5 之外的值在转化成二进制的过程中都丢失了精度。

// 业务中碰到的精度问题以及解决方案
// 了解 JavaScript 精度问题对我们业务有什么帮助呢？举个业务场景：比如有个订单号后端 Java 同学定义的是 long 类型，但是当这个订单号转换成 JavaScript 的 Number 类型时候精度会丢失了，那没有以上知识铺垫那就理解不了精度为什么会丢失。
// 解决方案大致有以下几种：
// 1.针对大数的整数可以考虑使用 bigint 类型(目前在 stage 3 阶段)；
// 2.使用 bigNumber，它的思想是转化成 string 进行处理，这种方式对性能有一定影响；
// 3.可以考虑使用 long.js，它的思想是将 long 类型的值转化成两个精度为 32 位的双精度类型的值。
// 4.针对小数的话可以使用 number-precision, 该库将小数转为整数后再作处理；

